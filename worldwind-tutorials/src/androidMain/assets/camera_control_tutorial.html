<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Camera Control Tutorial</title>
    <script src="file:///android_asset/codemirror-5.65.3/lib/codemirror.js" type="text/javascript"></script>
    <script src="file:///android_asset/codemirror-5.65.3/mode/mode.js" type="text/javascript"></script>
    <script src="file:///android_asset/codemirror-5.65.3/mode/kotlin/kotlin.js" type="text/javascript"></script>
    <link rel="stylesheet" type="text/css" href="file:///android_asset/codemirror-5.65.3/lib/codemirror.css"/>
    <link rel="stylesheet" type="text/css" href="file:///android_asset/override.css"/>
</head>
<body>
<h1>Camera Control Tutorial</h1>
<p>
    Demonstrates how to override the WorldWindowController gesture controller.
    </p>
<p>
    This advanced example uses the Cameras's interface in response to touch event gestures.</p>
<ul>
    <li>one-finger pan moves the geographic location of the camera,</li>
    <li>two-finger pinch-zoom adjusts the camera altitude,</li>
    <li>two-finger rotate rolls the camera around its own axis,</li>
    <li>two-finger tilt tilts and rotates the camera around its own axis.</li>
</ul>

<h2>Example</h2>
<h3>CameraControlFragment.kt</h3>
<p>
    The CameraControlFragment class extends the BasicGlobeFragment and overrides the createWorldWindow method.
    Here we set the WorldWindowController with our own CameraController inner class.
</p>
<div style="border-top: 1px solid black; border-bottom: 1px solid black;">
    <textarea id="kotlin-code">
class CameraControlFragment: BasicGlobeFragment() {
    /**
     * Creates a new WorldWindow object with a custom WorldWindowController.
     */
    override fun createWorldWindow() = super.createWorldWindow().apply {
        // Override the default "look at" gesture behavior with a camera centric gesture controller
        controller = CameraController(wwd)

        // Apply camera position above KOXR airport, Oxnard, CA
        engine.camera.setDegrees(
            latitudeDegrees = 34.2,
            longitudeDegrees = -119.2,
            altitudeMeters = 10000.0,
            altitudeMode = AltitudeMode.ABSOLUTE,
            headingDegrees = 90.0,
            tiltDegrees = 70.0,
            rollDegrees = 0.0
        )
    }

    /**
     * A custom WorldWindController that uses gestures to control the camera directly via the setAsCamera interface
     * instead of the default setAsLookAt interface.
     */
    private class CameraController(wwd: WorldWindow): BasicWorldWindowController(wwd) {
        private var beginAltitude = 0.0
        private var beginHeading = ZERO
        private var beginTilt = ZERO
        private var beginRoll = ZERO

        override fun handlePan(recognizer: GestureRecognizer) {
            val state = recognizer.state
            val dx = recognizer.translationX
            val dy = recognizer.translationY
            when (state) {
                BEGAN -> {
                    gestureDidBegin()
                    lastX = 0f
                    lastY = 0f
                }
                CHANGED -> {
                    wwd.engine.camera.run {
                        // Get the camera's current position.
                        var lat = position.latitude
                        var lon = position.longitude
                        val alt = position.altitude

                        // Convert the translation from screen coordinates to degrees. Use the camera's range as a metric for
                        // converting screen pixels to meters, and use the globe's radius for converting from meters to arc degrees.
                        val metersPerPixel = wwd.engine.pixelSizeAtDistance(alt)
                        val forwardMeters = (dy - lastY) * metersPerPixel
                        val sideMeters = -(dx - lastX) * metersPerPixel
                        lastX = dx
                        lastY = dy
                        val globeRadius = wwd.engine.globe.getRadiusAt(lat, lon)
                        val forwardRadians = forwardMeters / globeRadius
                        val sideRadians = sideMeters / globeRadius

                        // Adjust the change in latitude and longitude based on the camera's heading.
                        val sinHeading = sin(heading.radians)
                        val cosHeading = cos(heading.radians)
                        lat = lat.plusRadians(forwardRadians * cosHeading - sideRadians * sinHeading)
                        lon = lon.plusRadians(forwardRadians * sinHeading + sideRadians * cosHeading)

                        // If the camera has panned over either pole, compensate by adjusting the longitude and heading to move
                        // the camera to the appropriate spot on the other side of the pole.
                        if (lat.degrees < -90 || lat.degrees > 90) {
                            position.latitude = lat.normalizeLatitude()
                            position.longitude = lon.plusDegrees(180.0).normalizeLongitude()
                        } else if (lon.degrees < -180 || lon.degrees > 180) {
                            position.latitude = lat
                            position.longitude = lon.normalizeLongitude()
                        } else {
                            position.latitude = lat
                            position.longitude = lon
                        }
                        applyLimits(this)
                        wwd.requestRedraw()
                    }
                }
                ENDED, CANCELLED -> gestureDidEnd()
                else -> {}
            }
        }

        override fun handlePinch(recognizer: GestureRecognizer) {
            val state = recognizer.state
            val scale = (recognizer as PinchRecognizer).scaleWithOffset
            when (state) {
                BEGAN -> gestureDidBegin()
                CHANGED -> {
                    if (scale != 0f) {
                        // Apply the change in scale to the camera, relative to when the gesture began.
                        wwd.engine.camera.run {
                            position.altitude = beginAltitude / scale
                            applyLimits(this)
                            wwd.requestRedraw()
                        }
                    }
                }
                ENDED, CANCELLED -> gestureDidEnd()
                else -> {}
            }
        }

        override fun handleRotate(recognizer: GestureRecognizer) {
            val state = recognizer.state
            val rotation = (recognizer as RotationRecognizer).rotationWithOffset
            when (state) {
                BEGAN -> {
                    gestureDidBegin()
                    lastRotation = 0f
                }
                CHANGED -> {
                    wwd.engine.camera.run {
                        // Apply the change in rotation to the camera, relative to the camera's current values.
                        val rollDegrees = (lastRotation - rotation).toDouble()
                        roll = roll.minusDegrees(rollDegrees).normalize360()
                        lastRotation = rotation
                        applyLimits(this)
                        wwd.requestRedraw()
                    }
                }
                ENDED, CANCELLED -> gestureDidEnd()
                else -> {}
            }
        }

        override fun handleTilt(recognizer: GestureRecognizer) {
            val state = recognizer.state
            val dx = recognizer.translationX
            val dy = recognizer.translationY
            when (state) {
                BEGAN -> {
                    gestureDidBegin()
                    lastRotation = 0f
                }
                CHANGED -> {
                    wwd.engine.camera.run {
                        // Apply the change in tilt to the camera, relative to when the gesture began.
                        val headingDegrees = (180 * dx / wwd.width).toDouble()
                        val tiltDegrees = (-180 * dy / wwd.height).toDouble()
                        heading = beginHeading.minusDegrees(headingDegrees).normalize360()
                        tilt = beginTilt.minusDegrees(tiltDegrees)
                        applyLimits(this)
                        wwd.requestRedraw()
                    }
                }
                ENDED, CANCELLED -> gestureDidEnd()
                else -> {}
            }
        }

        override fun gestureDidBegin() {
            if (activeGestures++ == 0) {
                wwd.engine.camera.run {
                    beginAltitude = position.altitude
                    beginHeading = heading
                    beginTilt = tilt
                    beginRoll = roll
                }
            }
        }

        private fun applyLimits(camera: Camera) {
            val position = camera.position
            val distanceToExtents = wwd.engine.distanceToViewGlobeExtents * 1.1
            val minAltitude = 100.0
            position.altitude = position.altitude.coerceIn(minAltitude, distanceToExtents)

            // Check if camera altitude is not under the surface
            val ve = wwd.engine.verticalExaggeration
            if (position.altitude < COLLISION_CHECK_LIMIT * ve + COLLISION_THRESHOLD) {
                val elevation = wwd.engine.globe.getElevationAtLocation(
                    position.latitude, position.longitude
                ) * ve + COLLISION_THRESHOLD
                if (elevation > position.altitude) position.altitude = elevation
            }

            // Limit the tilt to between nadir and the horizon (roughly)
            val r = wwd.engine.globe.getRadiusAt(position.latitude, position.longitude)
            val maxTilt = Math.toDegrees(asin(r / (r + position.altitude)))
            val minTilt = 0.0
            camera.tilt = fromDegrees(camera.tilt.degrees.coerceIn(minTilt, maxTilt))
        }

        companion object {
            private const val COLLISION_CHECK_LIMIT = 8848.86 // Everest mountain altitude
            private const val COLLISION_THRESHOLD = 20.0 // 20m above surface
        }
    }
}
    </textarea>
</div>

<script type="text/javascript">
      var javaEditor = CodeMirror.fromTextArea(document.getElementById("kotlin-code"), {
        lineNumbers: true,
        matchBrackets: true,
        mode: "google-kotlin",
        readOnly: true
      });


</script>
</body>
</html>